
Next:

    Do a thorough commenting pass.
        Continue at keyboard.go.
    Add UI for switching disks.
    Get Eliminator to work for Larry:
        http://www.trs-80.org/the-eliminator/
        http://www.trs-80.org/games-by-wayne-westmoreland-and-terry-gilman/
        Needs handling of multiple drives.
    Deal with JSON send I/O timeouts.
        Detecting it and looping makes it lock up. Deadlock?
        Maybe just massively reduce bytes used per update.
            Use simple "c,addr,byte" format with one-letter command:
                p,15360,191
                p3C00BF
            Or allow multiple bytes per poke, in increasing RAM order.
            Would still need bulk commands, maybe separated by semicolon.

References:

    Best one:
        http://www.zilog.com/docs/z80/um0080.pdf
    Others:
        http://nemesis.lonestar.org/computers/tandy/software/apps/m4/qd/opcodes.html
        http://wikiti.brandonw.net/index.php?title=Z80_Instruction_Set
        http://clrhome.org/table/
        http://guide.ticalc.org/download/z80.txt
        http://www.trs-80.com/trs80-zaps-internals.htm
        http://members.shaw.ca/gp2000/trsdisk/trsdisk.html
            Accessing host filesystem from emulation.
    Emulators:
        http://sdltrs.sourceforge.net/

Disk notes:

    http://www.ece.msstate.edu/~reese/EE3724/lectures/fixdisk/fixdisk.pdf
        5.25" disks typically have 40 tracks, 9 sectors/track, 300 RPM, 360K
    http://en.wikipedia.org/wiki/Floppy_disk_format
        Sectors are usually 256 or 512 bytes.
        35-40 tracks of 9 512-byte sectors or 18 256-byte sectors.
        360K = 9 sectors, 320K = 8 sectors.
    http://en.wikipedia.org/wiki/List_of_floppy_disk_formats
        Nothing about TRS-80.
    http://en.wikipedia.org/wiki/TRS-80
        Model I used Western Digital 1771 chip, unreliable.
        Model III used Western Digital 1791
        All TRS-80 formats are soft-sectored (?) and have 40 tracks.
        Needed second index hole to flip disk.
        Drives sold by Radio Shack had 35 tracks, 160K.
    http://en.wikipedia.org/wiki/Western_Digital_FD1771
    Math:
        90000/40/9 = 250
        Files are 89600 bytes, so missing 400 bytes.
        Header seems to continue until 02400 = 1280 = 0x500
        89600 - 1280 = 88320
        88320/40/8 = 276 = 256 + 20
        Headers are identical in both files.
        89600/1280 = 70 = 35*2
        89600/35 = 2560 = 1280*2
        2360/8 = 320
        Another break at 012000 = 02400*4
        So guessing:
            No header, everything is data.
                First 1280 bytes have NO SYSTEM etc, so can't be raw header.
            89,600 bytes total.
            35 tracks = 2560 bytes per track.
            8 sectors = 320 bytes per sector.
            5 sectors = 512 bytes per sector.
                Can't be, first section is 1280 bytes.
            10 sectors = 256 bytes per sector.
        First few bytes of file are:
            00              NOP
            fe  11          CP 11   (0x11 = 17; 17th track is special?)
            f3              DI
            31  fc  41      LD SP, 41FC
            21  e2  42      LD HL, 42E2
            cd  9a  42      CALL 429A
            3e  01          LD A, 01
            32  e1  37      LD (37E1), A
            3a  02  42      LD A, (4202)
            57              LD D, A
        So except for first 3 bytes, it's definitely code. No header.
    JV3:
        Disk has 1 or 2 blocks describing sector layout.
        Each block is 34*256 = 8704 bytes.
        Each block can store info on 2901 sectors.
        Each info is:
            track
            sector
            flags
                Includes size of sector (128, 256, 512, or 1024 bytes)
        For each block:
            Load 2901 infos.
            Calculate position of each sector by adding their sizes (offset).
        For writing:
            For each size, we keep the ID of the first free sector of that size we find.
            Also keep track of the last non-free id, or -1 if none.
        Create permuting array (sorted_id) of sectors.
            Sort by:
                track
                side
                id
            Since now sorted that way, record start of each (track,side) index in sorted_id.




